<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Personale1</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>
<!-- da qui... -->

<!--
---------------------DATA BINDING--------------------
Si usa per mettere in collegamento la logica del componente con il template grafico.

TIPI DI DATA BINDING
- ONE WAY:
  - Interpolazione di stringhe
  - Property binding
  - Event binding
- TWO WAY

[Interpolazione di stringhe] - DALLO SCHERMO VERSO L'UTENTE
Definendo una proprietà es. "nome = paola" sul ts del componente, possiamo stampare a schermo il valore di "nome": <p>{{ nome }}</p>

[Property binding] - DALLO SCHERMO VERSO L'UTENTE
Possiamo manipolare le proprietà degli elementi HTML (es. le classi css), es: potremmo gestire dinamicamente tramite un true or false la proprietà "disabled" dell'HTML.

[Event binding] - DALL'UTENTE (click button) VERSO LO SCHERMO
Possiamo manipolare gli eventi degli elementi HTML (es. il click su un button)

[Two binding] - Il collegamento avviene da e verso ambo le parti, si usa per esempio quando si vuole far vedere a schermo in tempo reale all'utente quello che sta scrivendo (al di fuori del campo di input)

-----------DA APPROFONDIRE SINGOLARMENTE

-->

<!-- a qui...
  da spostare al giorno precedente
-->


<!--
---------------------INTERAZIONE TRA COMPONENT--------------------

Si usa per applicazioni medie o grandi, per ragioni di manutenzione. Quando c'è un component genitore e tanti component figli che condividono la stessa logica, per evitare di scrivere lo stesso codice su ogni figlio, si scrive un solo codice nel padre, e ogni figlio chiede al padre di eseguire quel codice.

@OUTPUT
Permette al componente figlio di inviare dati al componente padre.

ESEMPIO DI OUTPUT
Vogliamo un alert che saluti il figlio per nome. Normalmente potremmo scrivere la stessa logica su ogni figlio, ma ciò renderebbe il codice più lungo e meno mantenibile. Grazie all'output, possiamo inserire la logica nel padre e usare il figlio come parametro per fare in modo che per ciascun figlio il padre saluti con il nome giusto.

- Apriamo il TS del genitore e definiamo un metodo (es. "greet") che verrà chiamato dai figli
- Apriamo il TS del figlio e definiamo un metodo (es. "callParentGreet")
- Apriamo l'HTML del figlio e leghiamo il metodo "callParentGreet" al click su un bottone
- Apriamo il TS del figlio, creiamo una proprietà "greetEvent" che avrà come valore "new EventEmitter()", aggiungiamo la classe "EventEmitter" alla lista degli import, emettiamo l'evento chiamando il metodo dell'EventEmitter .emit dentro "callParentGreet()". Poi decoriamo la proprietà "greetEvent" con il decoratore @Output e importiamo la classe "Output" nel file.
- Il genitore adesso può catturare questo evento. Apriamo l'HTML del genitore e dentro il tag del figlio scriviamo il nostro custom event (esattamente come si fa normalmente con l'evento di click, per esempio). Quando "greetEvent" viene ricevuto dal genitore, esso chiama il metodo greet() definito all'inizio.
- Se vogliamo che il metodo venga eseguito in maniera diversa a seconda del tipo di figlio (es. deve dire "Ciao Paola" se il figlio si chiama "Paola"), bisogna usarlo in combinazione con dei parametri. Creiamo ad esempio dentro il TS del figlio la proprietà "name" = "Paola" e dentro il metodo emit inseriamo il parametro (this.name).
- Per passare" this.name" all'html del genitore bisogna usare il simbolo $, quindi il tag diventerà "app-child (greetEvent)="greet($event)"></app-child>"
- Modifichiamo il TS del genitore in maniera tale che il parametro che può ricevere il metodo "greet()" possa essere solo di tipo : string;, così che faccia un alert di ("Hello" + name); 

@INPUT
Permette al componente padre di inviare dati al componente figlio.

ESEMPIO DI INPUT
Immaginiamo di voler mostrare un messaggio di benvenuto, o una richiesta di loggarsi, a seconda che l'utente sia loggato oppure no. Normalmente, bisognerebbe specificare per ogni figlio una proprietà "loggato" di tipo booleano che sia true o false per ciascun figlio. Con il decoratore INPUT possiamo far gestire il valore di "loggato" dal genitore invece che dal figlio, così da migliorare la mantenibilità del codice.

- Creiamo la logica con un ngIf dentro l'HTML del figlio2 (mostra "Bentornato" o "loggati" a seconda del valore "loggato" che dobbiamo ancora definire)
- Dentro il TS del figlio creiamo la variabile "loggato" con valore di tipo boolean e le diamo un decoratore di tipo Input, che importiamo all'interno del file.
- Dentro il TS del genitore dobbiamo creare la proprietà "utenteLoggato" che verrà passata ai figli. Impostiamola su "true" per testare il codice.
- Dentro l'HTML del genitore all'interno del tag del figlio dobbiamo inserire il valore che si aspetta, ovvero [loggato], e il valore che le viene assegnato, ovvero "utenteLoggato"
-->


<!--
--------------CONTENT PROJECTION-------------------------------
È una tecnica in cui si inserisce ( o si proietta) il contenuto che si desidera utilizzare all'interno di un altro componente. Permette di creare componenti flessibili e riutilizzabili.

COME FUNZIONA
È possibile accettare contenuto da una sola fonte o da più fonti:

Es.
HTML genitore:

  <div>
      <app-product>
          <h4>New in Iphone</h4>
      </app-product>
  </div>
  <div>
      <app-product>
          <h4>New in Samsung</h4>
      </app-product>
  </div>
  <div>
      <app-product>
          <h4>New in OnePlus</h4>
      </app-product>
  </div>

HTML figlio:

  <div>
    <ng-content></ng-content>
  </div>

  In questo modo, il figlio renderizzato nella pagina del padre sarà preceduto dall'h4 specifico che è stato scritto nel padre, all'interno del tag figlio.

COSA FARE QUANDO SI HA BISOGNO DI PIU' DI 1 NG CONTENT
Es. se vogliamo mostrare dinamicamente un titolo e un button, e avere lo stesso testo per tutti i componenti, potremmo avere un figlio composto così:

  <div>
      <ng-content></ng-content>
      <p>contenuto</p>
      <ng-content></ng-content>
  </div>

  e un genitore composto così:

  <div>
      <app-product>
          <h4>New in OnePlus</h4>
          <button>Discover more</button>
      </app-product>
  </div>

ma in questo modo verrebbe renderizzato solo il secondo ng-content e verrebbe ignorato il primo.
Possiamo quindi usare dei selettori per risolvere il problema, es:

<ng-content select=".title"></ng-content>
<ng-content select=".btn-more"></ng-content>
-->



<!--
---------------CICLI DI VITA DEI COMPONENTI-----------------------

I lifecycle hooks sono punti di controllo all'interno del ciclo di vita di un componente Angular. Questi punti di controllo permettono di intercettare e modificare il comportamento del componente in momenti chiave del suo ciclo di vita.

Un singolo componente può avere più lifecycle hooks, usando le interfacce Lifecycle Hook nel core della angular library. Ciascuna interfaccia definisce uno specifico metodo di hooking, il cui prefisso inizia per ng, es. ngOnInit. A seconda del tipo di componente, possiamo avere diversi tipi di interfacce di hooking.

Per i componenti generici, possiamo avere:

- ngOnChanges -> viene chiamato quando la proprietà legata all'input cambia
- ngOnInit -> viene chiamato all'inizializzazione del componente
- ngDoCheck -> serve per gli sviluppatori per creare un sistema di rilevamento changes personalizzato, viene chiamato ad ogni rilevamento di cambiamenti
- ngOnDestroy -> viene chiamato appena prima di distruggere la direttiva o il componente.

Per i componenti figli, possiamo avere altri 4 tipi di hook, che vengono eseguiti tra l'ngDoCheck e l'ngOnDestroy del genitore:

- ngAfterContentInit -> chiamato quando il contenuto del componente viene inizializzato
- ngAfterContentChecked -> chiamato quando il contenuto del componente viene aggiornato o vengono controllati i suoi aggiornamenti
- ngAfterViewInit -> chiamato quando la renderizzazione del contenuto del componente viene inizalizzata
- ngAfterViewChecked -> chiamato quando la renderizzazione del contenuto del componente è stata controllata.

SINTASSI
- Dentro il TS del componente su cui fare qualcosa con gli hook (in questo esempio si trova nel componente "figlio3"), tra gli import bisogna importare OnInit, nella classe si possono inizializzare gli hook (es. ngOnInit(): void...), e accanto alla dichiarazione della classe bisogna implementare le interfacce corrispondenti (es. OnInit)
-->