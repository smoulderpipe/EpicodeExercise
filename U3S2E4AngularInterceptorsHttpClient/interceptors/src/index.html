<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Interceptors</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>

<!--

---------------------INTERCEPTORS----------------------------

A COSA SERVONO
Ci aiutano a modificare le HTTP Request (o le Response) intercettandole prima che arrivino al server.

COME FUNZIONANO
- L'interceptor cattura globalmente richieste incoming e outgoing.
- Possiamo usarli per aggiungere custom headers alle richieste outgoing, fare un console.log dell'incoming response, etc...

FLUSSO CLIENT - INTERCEPTOR(S) - SERVER
Client >>>>> Interceptor 1 >>>>> Interceptor 2 >>>>> Server
             next()              next()
<<<<<<<<<<<<<<< HTTP RESPONSE <<<<<<<<<<<<<<<<<<<<<<<<<<<<

ESEMPIO DI UTILIZZO (SEMPLICE LOG DELLA RICHIESTA)
1) Tramite CLI generiamo un nuovo service "auth-interceptor2.interceptor.ts" nella cartella "services", con il comando
"ng generate interceptor nomeInterceptor"
2) Il file generato avrà già importato, implementato e intercettato ciò che serve per farlo funzionare (importazioni: Injectable, HttpRequest, HttpHandler, HttpEvent, HttpInterceptor, Observable) (implementazioni: HttpInterceptor) (intercettazioni: "intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>>")
3) Adesso tutte le richieste HTTP che partiranno dal server o dal client verranno intercettate (si può testare con un console.log)
4) Importante notare che tutte le richieste degli interceptor devono essere seguite da un "next.handle(request)" altrimenti non andrà avanti

ESEMPIO DI UTILIZZO (MANIPOLAZIONE RICHIESTA)
Un oggetto di tipo richiesta è immutabile, quindi con gli interceptor creiamo delle copie di quella richiesta e modifichiamo le copie. In questo caso vogliamo impostare un'auth key e il suo valore, in maniera tale da permettere a tutte le richieste che partono dal client di avercela già pronta negli headers, senza doverla riscrivere in ogni ts dove c'è una richiesta.
1) Creiamo un clone della richiesta "const modifiedReq = request.clone();" dentro l'intercept
2) Passiamo ciò che vogliamo modificare nel clone, come parametro del clone, in questo caso { headers: req.headers.append('auth', 'abcxyz')}, ovvero: "il contenuto del nuovo header sarà uguale al vecchio header, ma in più conterrà un'auth e il suo valore"
3) facciamo "return next.handle(modifiedReq)" per fare il modo che l'interceptor ritorni la richiesta modificata
4) Andando sul browser ispeziona > network > click sulla richiesta > headers, possiamo vedere che dentro i "request headers" è apparsa la proprietà "auth" con valore "abcxyz" che abbiamo inserito tramite interceptor.

ESEMPIO DI UTILIZZO (SEMPLICE LOG DELLA RISPOSTA)
Nell'esempio precedente la risposta ci arriva senza passare attraverso alcun interceptor, perché non ne sono stati usati.
Per modificare la risposta, dobbiamo usare l'operatore "tap" di RxJS.
 Pertanto:
1) Infiliamo "tap" dentro la richiesta modificata, attraverso il "pipe" (e importare il pipe nel file). Tap accetta come parametro una callback, che riceve come argomento un evento. Tra la richiesta e la risposta possono avvenire una serie di eventi, es "send", "response"...
2) All'interno dell'evento, controlliamo qual è il tipo di evento. Se è di tipo "response", allora facciamo un log della risposta.



 -->
